<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HOME DJ - ВК Мини-приложение</title>
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <style>
        /* Ваши стили остаются без изменений */
        :root {
            --accent-color: #FFFF00;
            --accent-dark: #CCCC00;
            --accent-shadow: rgba(255,255,0,0.5);
            --accent-hover: #FFD700;
            --cue-playing-color: #FF0000;
            --cue-shadow: rgba(255,0,0,0.5);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #000;
            color: #fff;
            padding: 10px;
            opacity: 0;
            animation: startupAnimation 2s forwards;
        }
        
        /* ... остальные стили без изменений ... */
        
    </style>
</head>
<body>
    <div class="container">
        <!-- Ваша HTML-разметка без изменений -->
    </div>

    <div class="developer-signature-hidden">Разработчик Первушин Е.Ю</div>

    <script>
        // Глобальные переменные
        let isAuthorized = false;
        let userData = null;
        let activeDeck = 'A';
        
        // Основная функция инициализации
        async function initializeApp() {
            try {
                // Инициализируем VK Bridge
                if (typeof vkBridge !== 'undefined') {
                    await vkBridge.send('VKWebAppInit', {});
                    console.log('VK Mini App initialized');
                    
                    document.getElementById('statusIndicator').classList.add('status-connected');
                    document.getElementById('statusText').textContent = 'Connected to VK';
                    
                    // Пытаемся получить информацию о пользователе
                    try {
                        const userInfo = await vkBridge.send('VKWebAppGetUserInfo', {});
                        handleAuthSuccess(userInfo);
                    } catch (error) {
                        console.log('User not authenticated, showing auth modal');
                        document.getElementById('authModal').style.display = 'block';
                    }
                } else {
                    console.log('VK Bridge not available, running in standalone mode');
                    document.getElementById('authModal').style.display = 'block';
                }
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('authModal').style.display = 'block';
            }
        }

        // Обработка успешной авторизации
        function handleAuthSuccess(userData) {
            isAuthorized = true;
            window.userData = userData;
            document.getElementById('authModal').style.display = 'none';
            
            updateUserInfo();
            document.getElementById('loadTrackA').classList.remove('disabled');
            document.getElementById('loadTrackB').classList.remove('disabled');
            
            // Загружаем аудиозаписи пользователя
            loadUserAudio();
        }

        // Обновление информации о пользователе
        function updateUserInfo() {
            if (window.userData) {
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('loginButton').style.display = 'none';
                
                document.getElementById('userName').textContent = 
                    `${window.userData.first_name} ${window.userData.last_name}`;
                
                const avatarImg = document.createElement('img');
                avatarImg.src = window.userData.photo_100 || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBmaWxsPSIjZmZmIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgZmlsbD0iIzMzMyIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIj5Vc2VyPC90ZXh0Pjwvc3ZnPg==';
                avatarImg.alt = 'User Avatar';
                document.getElementById('userAvatar').innerHTML = '';
                document.getElementById('userAvatar').appendChild(avatarImg);
            }
        }

        // Загрузка аудиозаписей пользователя
        async function loadUserAudio() {
            try {
                if (typeof vkBridge !== 'undefined') {
                    // Сначала получаем токен
                    const authResult = await vkBridge.send('VKWebAppGetAuthToken', {
                        app_id: 54153831,
                        scope: 'audio'
                    });
                    
                    const response = await vkBridge.send('VKWebAppCallAPIMethod', {
                        method: 'audio.get',
                        params: {
                            access_token: authResult.access_token,
                            count: 100,
                            v: '5.131'
                        }
                    });
                    
                    if (response && response.response) {
                        displayTracks(response.response.items);
                    } else {
                        throw new Error('Invalid response format');
                    }
                } else {
                    // Демо-режим
                    const demoTracks = [
                        {
                            id: 1,
                            title: 'Deep House Vibes',
                            artist: 'Deep House Collective',
                            duration: 225,
                        },
                        {
                            id: 2,
                            title: 'Techno Revolution',
                            artist: 'Techno Masters',
                            duration: 260,
                        }
                    ];
                    displayTracks(demoTracks);
                }
            } catch (error) {
                console.error('Error loading audio:', error);
                document.getElementById('playlistTracks').innerHTML = 
                    '<li class="playlist-empty">Ошибка загрузки аудиозаписей</li>';
            }
        }

        // Отображение треков
        function displayTracks(tracks) {
            const playlistTracks = document.getElementById('playlistTracks');
            playlistTracks.innerHTML = '';
            
            if (!tracks || tracks.length === 0) {
                playlistTracks.innerHTML = '<li class="playlist-empty">Аудиозаписи не найдены</li>';
                return;
            }
            
            tracks.forEach(track => {
                const li = document.createElement('li');
                li.className = 'playlist-track';
                li.dataset.id = track.id;
                li.dataset.title = track.title || 'Без названия';
                li.dataset.artist = track.artist || 'Неизвестный исполнитель';
                li.dataset.duration = track.duration || 180;
                
                // Генерация BPM для демо
                const bpm = Math.floor(Math.random() * 40) + 100;
                
                li.innerHTML = `
                    <div class="track-cover-modal">
                        <img src="https://source.unsplash.com/featured/?music,album&${Math.random()}" alt="${track.title || 'Трек'}">
                    </div>
                    <div class="track-info-modal">
                        <div class="track-name-modal">${track.title || 'Без названия'}</div>
                        <div class="track-artist-modal">${track.artist || 'Неизвестный исполнитель'} · ${formatTime(track.duration || 180)}</div>
                    </div>
                    <div class="track-bpm">${bpm}</div>
                `;
                
                li.addEventListener('click', function() {
                    const trackName = this.dataset.title;
                    const artistName = this.dataset.artist;
                    const duration = parseInt(this.dataset.duration);
                    const bpm = parseInt(this.querySelector('.track-bpm').textContent);
                    const coverUrl = this.querySelector('img').src;
                    
                    const durationFormatted = formatTime(duration);
                    
                    document.getElementById(`trackName${activeDeck}`).textContent = trackName;
                    document.getElementById(`trackArtist${activeDeck}`).textContent = artistName;
                    document.getElementById(`bpmLarge${activeDeck}`).textContent = bpm.toFixed(1);
                    document.getElementById(`totalTime${activeDeck}`).textContent = `/ ${durationFormatted}`;
                    
                    // Обновляем данные трека
                    if (!window.trackData) window.trackData = {};
                    if (!window.trackData[activeDeck]) window.trackData[activeDeck] = {};
                    
                    window.trackData[activeDeck].duration = duration;
                    window.trackData[activeDeck].currentTime = 0;
                    window.trackData[activeDeck].baseBpm = bpm;
                    
                    resetPitch(activeDeck);
                    
                    if (window.trackData[activeDeck].loop) {
                        window.trackData[activeDeck].loop.active = false;
                    }
                    
                    document.querySelectorAll(`.loop-btn[data-deck="${activeDeck}"]`).forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    updateTimeInfo(activeDeck);
                    analyzeTrack(activeDeck, trackName, artistName, bpm, durationFormatted, coverUrl);
                    
                    const bpmA = parseFloat(document.getElementById('bpmLargeA').textContent);
                    const bpmB = parseFloat(document.getElementById('bpmLargeB').textContent);
                    document.querySelector('.master-bpm-display').textContent = `Master: ${((bpmA + bpmB) / 2).toFixed(1)} BPM`;
                    
                    document.getElementById('playlistModal').style.display = 'none';
                });
                
                playlistTracks.appendChild(li);
            });
        }

        // Вспомогательные функции
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }
        
        function resetPitch(deckId) {
            const slider = document.getElementById(`pitch${deckId}`);
            if (slider) {
                slider.value = 0;
                const event = new Event('input');
                slider.dispatchEvent(event);
            }
        }
        
        function updateTimeInfo(deckId) {
            if (!window.trackData || !window.trackData[deckId]) return;
            
            const data = window.trackData[deckId];
            const currentTimeElement = document.getElementById(`currentTime${deckId}`);
            const remainingTimeElement = document.getElementById(`remainingTime${deckId}`);
            const progressElement = document.getElementById(`waveformProgress${deckId}`);
            const waveformContainer = document.getElementById(`waveformContainer${deckId}`);
            
            if (currentTimeElement) currentTimeElement.textContent = formatTime(data.currentTime);
            if (remainingTimeElement) remainingTimeElement.textContent = `-${formatTime(data.duration - data.currentTime)}`;
            
            if (progressElement && data.duration > 0) {
                const progressPercent = (data.currentTime / data.duration) * 100;
                progressElement.style.width = `${progressPercent}%`;
            }
            
            if (waveformContainer) {
                if (data.duration - data.currentTime <= 15 && data.duration - data.currentTime > 0) {
                    waveformContainer.classList.add('warning');
                } else {
                    waveformContainer.classList.remove('warning');
                }
            }
        }

        // Инициализация при загрузке DOM
        document.addEventListener('DOMContentLoaded', function() {
            // Инициализация переменных и обработчиков событий
            window.trackData = {
                A: { 
                    duration: 225, 
                    currentTime: 0, 
                    playing: false, 
                    interval: null, 
                    baseBpm: 128, 
                    loop: { active: false, startPoint: 0, endPoint: 0, beats: 0 },
                    originalKey: '--',
                    currentKey: '--'
                },
                B: { 
                    duration: 260, 
                    currentTime: 0, 
                    playing: false, 
                    interval: null, 
                    baseBpm: 135, 
                    loop: { active: false, startPoint: 0, endPoint: 0, beats: 0 },
                    originalKey: '--',
                    currentKey: '--'
                }
            };
            
            // Ваши обработчики событий и остальной код инициализации
            
            // Запускаем инициализацию приложения
            initializeApp().catch(console.error);
        });
    </script>
</body>
</html>


